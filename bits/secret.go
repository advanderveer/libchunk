package bits

import (
	"crypto/rand"
	"encoding/base64"
	"encoding/binary"
	"fmt"

	"github.com/restic/chunker"
)

const (
	//SecretSize describes the byte size of the AES-GCM shared secret
	SecretSize = 32
)

//Secret is the 32 byte key that scopes the deduplication
//and facilitates end-to-end encryption. The first 8 bytes
//are always a polynomial that can be used for CBC the rest
//should always be randomly generated bytes
type Secret [SecretSize]byte

//ZeroSecret is secret with only 0x00 bytes, it can be used
//to check if a secret is empty
var ZeroSecret = Secret{}

//Pol returns the first 8 bytes of the secret as a polynomial
func (s Secret) Pol() (p chunker.Pol) {
	i, _ := binary.Uvarint(s[:8])
	return chunker.Pol(i)
}

//Encode a secret into a byte slice
func (s Secret) Encode() (b []byte) {
	b = make([]byte, base64.URLEncoding.EncodedLen(len(s)))
	base64.URLEncoding.Encode(b, s[:])
	return b
}

//String implements the Stringer interface
func (s Secret) String() string {
	return base64.URLEncoding.EncodeToString(s[:])
}

//DecodeSecret attempts to decode a secret from a byte slice
func DecodeSecret(b []byte) (s Secret, err error) {
	if len(b) != base64.URLEncoding.EncodedLen(SecretSize) {
		return s, fmt.Errorf("provided secret is not of the correct length, must be '%d' characters long", base64.URLEncoding.EncodedLen(SecretSize))
	}

	buf := make([]byte, base64.URLEncoding.DecodedLen(len(b)))
	_, err = base64.URLEncoding.Decode(buf, b)
	if err != nil {
		return s, fmt.Errorf("Failed to decode '%s' as a valid secret: %v", string(b), err)
	}

	copy(s[:], buf)
	return s, nil
}

//GenerateSecret will create a new secret with a random
//(irreducable) polynomial and random bytes to fill up the space.
func GenerateSecret() (s Secret, err error) {
	pol, err := chunker.RandomPolynomial()
	if err != nil {
		return s, fmt.Errorf("failed to generate polynomial")
	}

	n := binary.PutUvarint(s[:], uint64(pol))
	if n != 8 {
		return s, fmt.Errorf("failed to write polynomial to secret")
	}

	n, err = rand.Read(s[8:])
	if err != nil {
		return s, fmt.Errorf("failed to fill secret with random bytes: %v", err)
	} else if n != (KeySize - 8) {
		return s, fmt.Errorf("failed to write correct number of bytes to secret: %v", err)
	}

	return s, nil
}
